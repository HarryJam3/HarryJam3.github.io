<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iMeThi7ck</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-08-31T21:16:53.841Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/09/01/hello-world/"/>
    <id>http://example.com/2024/09/01/hello-world/</id>
    <published>2024-08-31T21:16:53.841Z</published>
    <updated>2024-08-31T21:16:53.841Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浅析LCTの初步使用及具体操作</title>
    <link href="http://example.com/2022/10/11/LCT/"/>
    <id>http://example.com/2022/10/11/LCT/</id>
    <published>2022-10-11T01:00:00.000Z</published>
    <updated>2024-09-03T14:56:00.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-闲话-·-LCT-的用途以及具体思路"><a href="#0x01-闲话-·-LCT-的用途以及具体思路" class="headerlink" title="$0x01$  闲话 · $LCT$的用途以及具体思路"></a>$0x01$  闲话 · $LCT$的用途以及具体思路</h2><p>$LCT$是啥？百度一下的话……貌似是一种检查妇科病的东西？<del>Oier的口味可是真不一般啊</del></p><p>咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得$LCT$其实就是一个用来维护森林连通性的。</p><p>嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，$LCT$是更加全能的树剖。</p><p>但其实吧……$LCT$打板子是很简单的，但是真正理解却一点儿也不简单。</p><p>因为本身$splay$就很麻烦了，况且$splay$之前一直用于维护数列。</p><p>要知道，此处的$splay$可是作为辅助树，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转$Luogu3391$，在$LCT$里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。</p><p>显而易见的是，$LCT$虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（亲测$50+$行），与$FFT$（快速傅里叶变换）一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。</p><p>也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完$LCT$，网上的每一篇博客都包教包会。</p><p>但是我今天要整理的，是对于$LCT$真正的理解。希望各位看到这篇拙作的人可以获得一些什么。</p><h2 id="0x02-闲话-·-关于-splay"><a href="#0x02-闲话-·-关于-splay" class="headerlink" title="$0x02$  闲话 · 关于$splay$"></a>$0x02$  闲话 · 关于$splay$</h2><p>道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？后宫佳丽三千我该翻谁的牌子呢$qwq$</p><p>历史的重任最后落到了$splay$​的身上。然后$splay$​他居然傲娇了：</p><p><img src="https://img2018.cnblogs.com/blog/1452231/201902/1452231-20190219115345555-1738304455.png"></p><p>……</p><p>好吧，由于某些<del>神犇也不知道的</del>原因，如果不用$splay$的话，复杂度是均摊$O(nlog2n)$, 而用$splay$就可以做到均摊$O(nlogn)$ ……但事实上，$splay$确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合$LCT.$</p><h2 id="0x03-LCT-的思路和基础操作"><a href="#0x03-LCT-的思路和基础操作" class="headerlink" title="$0x03$  $LCT$的思路和基础操作"></a>$0x03$  $LCT$的思路和基础操作</h2><h3 id="一-主要思路"><a href="#一-主要思路" class="headerlink" title="一 主要思路"></a>一 主要思路</h3><p>主要思路嘛……</p><p>****大概是基于实链剖分的操作。</p><p>朴素的树剖是重链剖分，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到$log$级别。而遗憾的是$LCT$维护的是森林的连通性，所以只能采用实链剖分。</p><p>而实链剖分大体上就是把边分为虚边和实边。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵$splay$中。$splay$和$splay$之间由虚边相连。</p><p>实链剖分的好处呢？在于实链剖分是一种动态剖分，他可以随意改变边的虚实属性。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。$So$，实链剖分为动态树的动态打下了基础。</p><p>那么接下来我们来看一个$​LCT$​是如何定义的:</p><p>首先，一棵$LCT$​管控的是一对分散的点，点以几棵分散的splay​splay​的形式聚集。起初整棵LCT​LCT​是没有任何联系的，各自为战，各自为根。我们接下来会看到的$access$​、$makeroot$​等操作，都是在自己的联通块儿内部进行的操作。换句话讲，$LCT$​维护的是有根森林，即组成森林的每个联通块都有其唯一的根。</p><p>实边串联起一个联通块，同一组实边存在、且仅存在于一棵splaysplay中。splaysplay和splaysplay之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。但是两种边都没有用到显式存储，都是通过$splay$中的$Son$数组和$Fa$数组访问的。但虚边和实边的存储有区别：</p><pre><code>虚边是认父不认子，即如果$Fa[x]==y$，那么$y$不存$x$这个儿子，但是$x$存$y$这个父亲。这样做是为了可以$Access$——因为其实在$Access$的子函数$splay$里，发挥作用的实际上是$Fa$指针。实边是完整的双向存储。</code></pre><p>$splay$中维护的是一条从存储上到下按在原树中深度严格递增的路径，且中序遍历$splay$得到的每个点的深度序列严格递增。换句话讲，一个$splay$里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵$splay$中，键值就是原树中的深度。<br>如果$x$是它所在$splay$的最左边的点，那么它在原森林里的父亲是$x$所在$splay$的根的$fa$, 否则就是$x$在$splay$上的前驱.</p><p>待更$……$</p>]]></content>
    
    
    <summary type="html">动态树问题，是一类要求维护一个有根树森林，支持对树的分割，合并等操作的问题，简称lct</summary>
    
    
    
    
    <category term="树的维护" scheme="http://example.com/tags/%E6%A0%91%E7%9A%84%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>iMeThi7ck の 代码规范（During Competitive Programming）</title>
    <link href="http://example.com/2022/09/20/iMeThi7ckCode/"/>
    <id>http://example.com/2022/09/20/iMeThi7ckCode/</id>
    <published>2022-09-20T01:00:00.000Z</published>
    <updated>2024-09-03T14:30:15.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>#include</code> 语句必须置于整个程序的开头。</p><p>不应 <code>using namespace foo;</code> 若有必要可以 <code>using foo::bar;</code></p><p>单行字符数必须不超过$80$。</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p><code>#include</code> 的多个库顺序可有以下两种：</p><p>$C++$标准库在前，之后是$C$标准库，再后为其它（如交互库等）（工程代码中，本 $cpp$ 所对应的 $.h$ 文件应置于开头。）<br>（仅适用于 $Oi$ ）按字典序依次排列。</p><p>如果有多层嵌套<code>#if #endif,#endif</code>后应有对应的注释标识出与其对应的<code>#if</code>。</p><p>尽量不要适用<code>#define</code>而使用 <code>const</code> ,  <code>typedef</code> , <code>inline</code>。</p><p>所有预编译命令不应缩进（见下）。</p><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>每个代码块采用 $2$ 空格缩进。</p><h2 id="空格及换行"><a href="#空格及换行" class="headerlink" title="空格及换行"></a>空格及换行</h2><p>大括号不换行。</p><h3 id="需要加空格的地方："><a href="#需要加空格的地方：" class="headerlink" title="需要加空格的地方："></a>需要加空格的地方：</h3><p>1.二元运算符（包括赋值运算符）两侧（运算符例外，见下）；<br>2<code>.,</code>及<code>;</code>的右边（如果其不处于行尾）；<br>3.<code>if</code>, <code>for</code>等控制流关键字与其后的左括号之间 ；<br>4.<code>do-while</code>中的<code>while</code>、<code>if-else</code>中的<code>else</code>与其前面的右大括号之间；<br>5.所有左大括号的左侧（根据不换行的策略，左大括号不应处于行首）；<br>6.<code>? :</code>的两侧（包括构造函数初始化列表中的<code>:</code>）；<br>类型中<code>*</code>,<code>&amp;</code>的左侧（如：<code>const int &amp;a</code>, <code>int A(int *&amp;a)</code>）；<br>花括号与其内部语句&#x2F;数组初始化列表之间（如果在同一行）；<br>常成员函数的<code>const</code>两侧。</p><h3 id="一定不能加空格的地方："><a href="#一定不能加空格的地方：" class="headerlink" title="一定不能加空格的地方："></a>一定不能加空格的地方：</h3><p>小括号及中括号与其内部的表达式&#x2F;参数列表之间；<br>函数名与左括号之间（包括声明&#x2F;定义&#x2F;使用）；<br>单目运算符（<code>!</code>,<code>-</code>,<code>*</code>,<code>&amp;</code>,<code>~</code>）之后（或自增自减运算符与其操作数之间）；<br><code>,</code>及<code>;</code>的左侧；<br>类型中*,&amp;的右侧；<br><code>.</code>,<code>-&gt;</code>,<code>::</code>的两侧；<br><code>operator</code>与所要重载的运算符之间（运算符与参数列表之间，根据第$2$条，也不应空格）。<br>若表达式过长内部可以换行，运算符处于行首（而非行尾）；缩进以使表达式对齐为准；换行的优先级较高的子表达式也应加括号以避免误读。</p><p>参数列表&#x2F;初始化列表过长时内部也可换行，逗号处于行尾；缩四空格。</p><p>极短的函数可以写到一行（但绝不能超过 $80$ 字符）。</p><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>所有<code>#include &lt;foobar&gt;</code>与<code>using foo::bar;</code>之间不应空行，之后应空一行。</p><p>一系列常量定义的上下应有空行。</p><p>函数&#x2F;结构体定义两侧应有空行（一系列短小到可以写到一行的函数，如min,max，之间可以不空行）。</p><p>一系列全局变量定义的上下应有空行。</p><p>语句之间可根据其意义酌情空行。</p><p>任何位置不能出现连续的两个（或以上）空行。</p><p>函数定义<br>$main$函数返回值必须为$int$,$return 0$不可忽略；</p><p>类&#x2F;结构体传参在大多数情况下不应传值（除非难以避免地产生拷贝，或一些特殊要求），而应传引用。</p><p>极其简短的函数可以写作一行（但绝不能超过 $80$ 字符），此时花括号内部应有空格（空函数体{}除外）。</p><p>单个函数的长度不应过长（例如超过 $100$ 行）。</p><p>命名规则<br>一般情况下应采用驼峰命名法，变量开头小写，函数&#x2F;类&#x2F;结构体开头大写。</p><p>结构体&#x2F;类成员函数，可以小写开头。</p><p>特例：</p><p>main函数；<br>变量可以以一个小写字母命名；<br>全局数组名可使用1个大写字母+0~2个数字命名，如A, T1,F01；<br>模板。如<code>readInt</code>, <code>pow_mod</code>;<br>采用对应算法缩写，如<code>KMP</code>, <code>CRT</code>, <code>NTT</code>,<code>CDQ</code>；<br>简短的<code>inline</code>函数，如<code>min</code>, <code>upd</code>(用作数据结构中的update操作);<br>常量可以大写字母命名，如<code>N</code>, <code>M</code>；<br>临时变量可以以下划线开头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">Example Code</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">readInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, c;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c = <span class="built_in">getchar</span>()));</span><br><span class="line">  <span class="keyword">do</span> ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = <span class="built_in">getchar</span>()));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">pow_mod</span><span class="params">(LL x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  LL ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ((p += mod - <span class="number">1</span>) %= (mod - <span class="number">1</span>); p; p &gt;&gt;= <span class="number">1</span>, (x *= x) %= mod)</span><br><span class="line">    <span class="keyword">if</span> (p &amp; <span class="number">1</span>) (ans *= x) %= mod;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL inv[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(LL *A, <span class="type">int</span> len, <span class="type">int</span> opt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> k = len;</span><br><span class="line">    <span class="keyword">while</span> (~j &amp; k) j ^= (k &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) std::<span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">2</span>; h &lt;= len; h &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    LL wn = <span class="built_in">pow_mod</span>(g, (mod - <span class="number">1</span>) / h * opt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += h) &#123;</span><br><span class="line">      LL w = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; j + (h &gt;&gt; <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        LL _tmp1 = A[i], _tmp2 = A[i + (h &gt;&gt; <span class="number">1</span>)] * w;</span><br><span class="line">        A[i] = (_tmp1 + _tmp2) % mod;</span><br><span class="line">        A[i + (h &gt;&gt; <span class="number">1</span>)] = (_tmp1 - _tmp2) % mod;</span><br><span class="line">        (w *= wn) %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opt == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      (A[i] *= -(mod - <span class="number">1</span>) / len) %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL F[N], G[N];</span><br><span class="line">LL T1[N * <span class="number">4</span>], T2[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Conv</span><span class="params">(LL *A, <span class="type">int</span> n, LL *B, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (len &lt;= n + m) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    T1[i] = (i &lt; n ? A[i] : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    T2[i] = (i &lt; m ? B[i] : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NTT</span>(T1, len, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">NTT</span>(T2, len, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    (T1[i] *= T2[i]) %= mod;</span><br><span class="line">  <span class="built_in">NTT</span>(T1, len, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r - <span class="number">1</span>) &#123;</span><br><span class="line">    F[l] = (l == <span class="number">0</span> ? <span class="number">1</span> : F[l] * inv[l] % mod);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Solve</span>(l, mid);</span><br><span class="line">  <span class="built_in">Conv</span>(F + l, mid - l, G, r - l);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &lt; r; ++i)</span><br><span class="line">    (F[i] += T1[i - l]) %= mod;</span><br><span class="line">  <span class="built_in">Solve</span>(mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">readInt</span>();</span><br><span class="line"></span><br><span class="line">  inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = -(mod / i) * inv[mod % i] % mod;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;G[i]);</span><br><span class="line">    (G[i] *= i) %= mod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Solve</span>(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (F[i] + mod) % mod);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">这是曾OIer/XCPCer在役期间一套约束自己的代码规范方案</summary>
    
    
    
    
    <category term="Standard" scheme="http://example.com/tags/Standard/"/>
    
  </entry>
  
  <entry>
    <title>「Sekai CTF 2022」Pafs - 树形 DP</title>
    <link href="http://example.com/2021/03/07/Sekaictf2022/sekaictf-2022-pafs/"/>
    <id>http://example.com/2021/03/07/Sekaictf2022/sekaictf-2022-pafs/</id>
    <published>2021-03-07T01:00:00.000Z</published>
    <updated>2024-09-04T01:28:45.962Z</updated>
    
    <content type="html"><![CDATA[<p>给定一棵有 $N$ 个节点的无根树，对每条无向边编号（$(a,b)$ 和 $(b,a)$ 被认为是同一条边），定义一种新的路径 Pafs：一条 Pafs 路径是若干条不重复的边组成的序列，序列中两个相邻的边之间必须有且仅有一个公共端点。Pafs 路径是有向的，且相邻的边不需要首尾相连，如下图：</p><p><img src="/paf.svg" alt="一个合法的 Pafs 路径"></p><p>求给定的树上共有多少条 Pafs 路径，答案 $\mathop{\text{mod}} ~ 10^9+7$。</p><span id="more"></span><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://algo-server.ctf.sekai.team/">Project SEKAI Online Judge</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑每条 Pafs 路径的形态：一定是以一条普通的路径作为主要部分，外加其中每个点都可以额外引入若干条分叉边。所以从主路径入手考虑这个问题。</p><p>对无根树进行 DFS，转化为有根树。在树上进行树形 DP，为每个节点 $i$ 维护两个值：</p><ul><li>$g(i)$ 表示，主路径在该节点的子树（外加该节点的父节点）内，主路径从下向上以该节点的父节点结束，最后一条边为该节点与其父节点相连的边，的 Pafs 路径数量；<ul><li>仅对非根节点有定义</li><li>根据定义最后一条边也可以算作分叉边，但为了解题这里将其算作主路径；</li><li>仅统计从下向上一个方向，其中除单条边组成的以外，每个对应一个反转的路径；</li></ul></li><li>$s(i)$ 表示，主路径在该节点的子树内，主路径经过的深度最小的点为该节点，的 Pafs 路径数量。</li></ul><p>最终答案为所有 $s(i)$ 之和。</p><h4 id="g-i"><a href="#g-i" class="headerlink" title="g(i)"></a>g(i)</h4><p>对于每个节点，其每个子节点 $j$ 的 $g(j)$ 中的每个 Pafs 路径均对 $g(i)$ 有贡献。从每个子节点 $j$ 引入的 Pafs 路径，在到达当前节点 $i$ 之后，由于最后一条边属于主路径，所以可以再加入若干条分叉边，这些可供选择分叉边即为 $i$ 与其他子节点 $k$ 相连的边。</p><p>设 $i$ 共有 $c(i)$ 个子节点，此时一共有 $c(i)-1$ 条边可供选择。由于 Pafs 路径是有序的，所以分叉边的选择方案也是有序的，所以此时的方案数为：从 $n&#x3D;c(i)-1$ 条边中任选一条或多条边，并组成全排列，的方案数，即</p><p>$$<br>\begin{aligned}<br>a(n)&amp;&#x3D;\sum\limits_{m&#x3D;0}^{n}A(n,m)\<br>&amp;&#x3D;\sum\limits_{m&#x3D;0}^{n}\frac{n!}{(n-m)!}\<br>\end{aligned}<br>$$</p><blockquote><p>由于 $n&#x3D;c(i)-1$ 的最大值为 $O(N)$ 级别（考虑菊花图），所以不能使用时间复杂度为 $O(n)$ 的算法来计算单个 $a(n)$。将 $a(n)$ 的前 10 项输出，可得 </p><p>$$1,2,5,16,65,326,1957,13700,109601,986410$$</p><p>在 OEIS 上搜索，得到数列 <a href="https://oeis.org/A000522">A000522</a>，并获得线性递推式</p><p>$$a(n)&#x3D;na(n-1)+1$$</p><p>使用该递推式可在 $O(n)$ 的时间内预处理所有 $a(n)$ 值。</p></blockquote><p>所以，对非根节点 $i$</p><p>$$<br>g(i)&#x3D;\sum\limits_{j\in\mathop{\text{child}}(i)}g(j)a(c(i)-1)+1<br>$$</p><h4 id="s-i"><a href="#s-i" class="headerlink" title="s(i)"></a>s(i)</h4><p>每个节点的 $s(i)$ 分为两个个部分：</p><ol><li>$s_1(i)$，表示以该节点的父节点作为最后一条边，且这条边作为主路径，且主路径上每个点深度递减的 Pafs 路径（以及其相反的路径）数量，显然 $s_1(i)&#x3D;g(i)\times2-1$（减 $1$ 以去除单条边组成的路径被重复计算两次的情况）；</li><li>$s_2(i)$，表示主路径可分为在 $i$ 的不同子树内的两部分，且主路径所有节点的最近公共祖先为 $i$，的 Pafs 路径数量。</li></ol><p>对于第二部分，考虑主路径从一个子节点 $j$ 向上到达当前节点，再向下到另一个子节点 $j$。由于在 $g(j)$ 的定义中，每条 Pafs 路径均以 $j-i$ 的边作为主路径结束，所以 $j-i-k$ 之间可以引入若干条分叉边，这些分叉边可以包含与其他 $c(i)-2$ 个子节点相连的边，也可以包含与父节点相连的边，所以共有 $c(i)-1$ 种选择。所以</p><p>$$<br>s_2(i)&#x3D;\sum\limits_{j\in\mathop{\text{child}}(i)}\sum\limits_{k\in\mathop{\text{child},k\neq j}(i)}g(j)g(k)a(c(i)-1)<br>$$</p><p>所以</p><p>$$<br>s(i)&#x3D;\begin{cases}<br>\sum\limits_{j\in\mathop{\text{child}}(i)}g(j)\left(\sum\limits_{k\in\mathop{\text{child}}(i),k\neq j}g(k)\right)a(c(i)-1)+2g(i)-1&amp;i\text{ is NOT root}\<br>\sum\limits_{j\in\mathop{\text{child}}(i)}g(j)\left(\sum\limits_{k\in\mathop{\text{child}}(i),k\neq j}g(k)\right)a(c(i)-1)&amp;i\text{ is root}<br>\end{cases}<br>$$</p><p>其中 $\sum\limits_{k\in\mathop{\text{child},k\neq j}(i)}g(k)$ 可以通过预处理所有子节点的 $g(k)$ 之和并减去 $g(j)$ 的方法来简化计算，不需要两层循环枚举分别所有子节点。</p><p>时间复杂度为 $O(n)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int64_t</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::vector&lt;Node *&gt; adj;</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Node *&gt; children;</span><br><span class="line">    <span class="type">int64_t</span> g, s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;adj.<span class="built_in">push_back</span>(v);</span><br><span class="line">    v-&gt;adj.<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int64_t</span>&gt; p0Cache;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inline void exgcd(int64_t a, int64_t b, int64_t &amp;g, int64_t &amp;x, int64_t &amp;y) &#123;</span></span><br><span class="line"><span class="comment">//     if (!b) g = a, x = 1, y = 0;</span></span><br><span class="line"><span class="comment">//     else exgcd(b, a % b, g, y, x), y -= x * (a / b);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inline int64_t inv(int64_t num) &#123;</span></span><br><span class="line"><span class="comment">//     int64_t g, x, y;</span></span><br><span class="line"><span class="comment">//     exgcd(num, MOD, g, x, y);</span></span><br><span class="line"><span class="comment">//     return ((x % MOD) + MOD) % MOD;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">preprocess</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::vector&lt;int64_t&gt; frac(n + 1);</span></span><br><span class="line">    <span class="comment">// frac[0] = 1;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) frac[i] = frac[i - 1] * i % MOD;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p0Cache.resize(n + 1);</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt;= n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt;= i; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         (p0Cache[i] += frac[i] * inv(frac[i - j]) % MOD) %= MOD;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;P0(%d) = %llu\n&quot;, i, p0Cache[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    p0Cache.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    p0Cache[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p0Cache[i] = (p0Cache[i - <span class="number">1</span>] * i + <span class="number">1</span>) % MOD;</span><br><span class="line">        <span class="comment">// printf(&quot;P0(%d) = %llu\n&quot;, i, p0Cache[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line">    u-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node *v : u-&gt;adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;visited) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">            u-&gt;children.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> p0 = u-&gt;adj.<span class="built_in">size</span>() &lt; <span class="number">2</span> ? <span class="number">0</span> : p0Cache[u-&gt;adj.<span class="built_in">size</span>() - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> notRoot = u-&gt;adj.<span class="built_in">size</span>() != u-&gt;children.<span class="built_in">size</span>();</span><br><span class="line">    u-&gt;g = u-&gt;s = notRoot ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int64_t</span> sumOfG = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node *ci : u-&gt;children) (sumOfG += ci-&gt;g) %= MOD;</span><br><span class="line">    <span class="keyword">for</span> (Node *ci : u-&gt;children) &#123;</span><br><span class="line">        (u-&gt;s += ci-&gt;g * p0 % MOD * ((sumOfG - ci-&gt;g + MOD + (notRoot ? <span class="number">2</span> : <span class="number">0</span>)) % MOD) % MOD) %= MOD;</span><br><span class="line">        (u-&gt;g += ci-&gt;g * p0 % MOD) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;g(%d) = %llu\n&quot;, u-&gt;id, u-&gt;g);</span></span><br><span class="line">    <span class="comment">// printf(&quot;s(%d) = %llu\n&quot;, u-&gt;id, u-&gt;s);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">preprocess</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[u - <span class="number">1</span>], &amp;nodes[v - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nodes[i].id = i + <span class="number">1</span>;</span><br><span class="line">        nodes[i].visited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(&amp;nodes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) (answer += nodes[i].s) %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, answer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">给定一棵有 N 个节点的无根树，对每条无向边编号（(a,b) 和 (b,a) 被认为是同一条边），定义一种新的路径 Pafs：一条 Pafs 路径是若干条不重复的边组成的序列，序列中两个相邻的边之间必须有且仅有一个公共端点。</summary>
    
    
    
    
    <category term="组合数学" scheme="http://example.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="树形dp" scheme="http://example.com/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>图论の奇技淫巧</title>
    <link href="http://example.com/2020/02/09/Graph1/"/>
    <id>http://example.com/2020/02/09/Graph1/</id>
    <published>2020-02-09T06:00:00.000Z</published>
    <updated>2024-09-01T00:31:09.228Z</updated>
    
    <content type="html"><![CDATA[<p>图论，其实是数学的一门分支，它以图为研究对象。最基础的图论应该是著名的哥尼斯堡七桥问题，那是一个经典的一笔画问题。</p><p>竞赛中我们比较常见的是 <strong>最短路算法 最小生成树算法 拓扑排序</strong> 等等。</p><p>本篇文章我们不说那些大家都懂烂了的图论算法，讲一些实用的 <del>(没什么用的)</del> 图论小技巧。</p><h2 id="链式前向星存图"><a href="#链式前向星存图" class="headerlink" title="链式前向星存图"></a>链式前向星存图</h2><p>最最基础的存图的基本分为两种，使用二维数组和使用 $vector$ ，但这两种方法都有所缺陷。</p><p>使用二维数组查询速度很快，但空间复杂度是 $O(n^2)$ 的，一般的题目都接受不了。</p><p>使用 $vector$ 可以减少空间复杂度，但是时间就比较不确定了。</p><p>所以就出现了一种神奇的存图方式，<strong>链表思想的链式前向星</strong>。</p><p>我们通常使用以下数组来完成</p><details><summary>$Codes$</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int w[i]//第 i 条边的权值</span><br><span class="line">int to[i]//第 i 条边的终点</span><br><span class="line">int nxt[i]//下一条的边的编号，不建议叫 next，会挂</span><br><span class="line">int head[i]//以 i 为起始点的第一条边</span><br><span class="line">int tot//边的编号</span><br></pre></td></tr></table></figure></details><p>新增加一条边的时候我们进行如下操作</p><details><summary>$Codes$</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void add(int x,int y,int z)&#123;</span><br><span class="line">    tot++;//新边的编号</span><br><span class="line">    to[tot]=y;//新一条边的信息</span><br><span class="line">    w[tot]=z;</span><br><span class="line">    nxt[tot]=head[x];</span><br><span class="line">    head[x]=tot;//更新以 x 为起始点的第一条边</span><br><span class="line">&#125;</span><br><span class="line">//这样是单向边，双向边要再来一次</span><br></pre></td></tr></table></figure></details><p>用下面这种方式就可以枚举出所有以 xx 为起始点的边。</p><details><summary>$Codes$</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=head[x];i;i=nxt[i])&#123;// i 即为该边编号</span><br><span class="line">    //to[i]为可以到达的点头</span><br><span class="line">    //w[i]为这条边的权值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>大致思想就是将所有以 $x$ 为起始点的边以链表的形式储存，枚举的时候遍历链表，直到边的编号为 $0$ (为 $0$ 表示没有其他的边了)</p><p>这样就可以满足我们从某个点遍历枚举下个点的需要。</p><p>前向星链表被疯狂应用在各个图论题目中，基本上是一个图论题都可以用到吧，属于非常基础的图论技能。</p><p><strong>需要注意的是对于双向边的题目，链式前向星的数组需要开边数的两倍，不然会 $RE$ 。</strong></p><h2 id="反向建边"><a href="#反向建边" class="headerlink" title="反向建边"></a>反向建边</h2><p>对于一个有向图，某些问题中我们需要反向建边来完成操作</p><p>比如求其他 $n$ 个点到 $k$ 点的最短路。</p><p><del>对每个点跑一遍最短路不就好了吗？</del></p><p>事实上我们只需要跑一遍最短路就可以了，只需要把边反向建。</p><p>反向建图情况下 $k$ 点到每个点的最短路就是正常情况下该点到 $k$ 点的最短路。</p><p>例题 <a href="https://www.luogu.com.cn/problem/P1629">P1629 邮递员送信</a></p><p>不只是最短路问题，在遍历问题上也可以使用反向建边来完成</p><p>例题 <a href="https://www.luogu.com.cn/problem/P3916">P3916 图的遍历</a></p><p>是否需要反向建边，根据题意判断即可。</p><p>反向建边还可以来判断某条边是否在最短路上。</p><p>对于一个有向图，我们从 11 号点跑一遍正向的最短路 $dis[]$ ，从 $n$ 号点跑一遍反向的最短路 $dis1[]$<br>如果 $dis[x]+w(x,y)+dis1[y]&#x3D;dis[n]$ 那么我们就可以得出，这条边是在 $1$ 到 $n$ 的最短路上的。</p><p>当然如果是无向图的话直接跑就可以了。</p><h2 id="虚点连边"><a href="#虚点连边" class="headerlink" title="虚点连边"></a>虚点连边</h2><p>虚点连边是一种很有效的优化建边复杂度的方式</p><p>我们可能会遇见这样一种题，给你几个点，其他的点离这些给出的点的最近距离是多少。</p><p>我们可以对于每一个点进行 $Spfa$，但似乎这样并不是很好操作。</p><p>我们可以自己给出一个点，然后向每个被标记的点连一条单向边，这样就只需要进行一次 $Spfa$ 就可以了。</p><p>举个例子，橙色为标记点，数字为最近距离。</p><p><img src="https://z4a.net/images/2019/02/25/k1ef821096fa7bd112.png"></p><p>例题 <a href="https://www.luogu.com.cn/problem/P3393">P3393 逃离僵尸岛</a></p><p>但似乎这个直接广搜也可以。</p><p>如果对于两个点集 $A$ 和 $B$，你需要对 $A$ 中的每一个点向 $B$ 中的每一个点都建一条边，如果直接操作，复杂度很明显是 $O(n^2)$ 的，有没有更快的方法呢？</p><p>我们可以建一个虚点 $P$ ，然后对 $A$ 里的每一个点向 $P$ 连一条单向边边，然后对 $P$ 向 $B$ 中的每一个点建一条单向边，这样只需要 $O(2n)$ 的复杂度就可以完成了。</p><p>画个图理解一下。</p><p>(优化前)</p><p><img src="https://z4a.net/images/2019/02/25/k2.png"></p><p>(优化后)</p><p><img src="https://z4a.net/images/2019/02/25/k3.png"></p><p>例题 <a href="https://www.luogu.com.cn/problem/P1983">P1983 车站分级</a></p><p>虚点连边只是听起来很高大上的操作，但实际上很简单。</p><p>对于有边权的情况，虚点连得边的边权需要注意(一般为 $0$ )</p><h2 id="线段树优化建边"><a href="#线段树优化建边" class="headerlink" title="线段树优化建边"></a>线段树优化建边</h2><p>说到优化建边，就一定要介绍一下线段树优化建边了。</p><p>这也是一个听起来非常高大上但实际上不是很难的技巧。</p><p>给你一个点 $X$ ，让你和一个点集里的每一个点都连一条边。看起来并没有什么好方法，只能乖乖地一个一个连</p><p>如果这个点集是连续的呢？我们就可以用线段树来优化建边了。</p><p>我们知道线段树是这个结构的</p><p><img src="https://z4a.net/images/2019/02/25/k4.png"></p><p>我们知道，线段树的点是能够代表一段区间的，那么我们怎样应用这个性质呢？</p><p>首先，我们需要对于线段树的每个父亲与他的儿子建一条单向边，效果如下 </p><p><img src="https://z4a.net/images/2019/02/25/k5.png"></p><p>这有什么用呢？因为我们所要求的点集是一段连续的区间，而线段树的结点可以表示某一段区间，我们可以在线段树上找到对应的区间，然后向线段树上的点建边，就可以加快建边速度了。</p><p>例如我们要向 $[1,8]$ 里的所有点建边，我们只需要将 $X$ 和线段树上 $[1,8]$ 那个点连一条单向边就可以了。</p><p>$[2,6]$ 的例子</p><p><img src="https://z4a.net/images/2019/02/25/k6.png"></p><p>我们在线段树上的边边权一般都是 $0$ ，边权直接赋给 $X$ 连到线段树上的那条边即可</p><p>建树和寻找的代码和普通线段树差不多。需要注意的是线段树上结点的编号不要和已有的点重复，最后的结点直接连上该点就好。</p><details><summary>$Codes$</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void build(int &amp;p,int l,int r)&#123;</span><br><span class="line">    if(l==r)&#123;</span><br><span class="line">        p=l;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    p=++cnt;//点的编号</span><br><span class="line">    int mid=l+r&gt;&gt;1;</span><br><span class="line">    build(lc[p],l,mid);build(rc[p],mid+1,r);</span><br><span class="line">    add(lc[p],p,0);add(rc[p],p,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update(int p,int l,int r,int x,int L,int R,int z)&#123;</span><br><span class="line">    if(L&lt;=l &amp;&amp; r&lt;=R)&#123;</span><br><span class="line">        add(x,p,z);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid=l+r&gt;&gt;1;</span><br><span class="line">    if(L&lt;=mid)&#123;</span><br><span class="line">        update(lc[p],l,mid,x,L,R,z);</span><br><span class="line">    &#125;</span><br><span class="line">    if(R&gt;mid) &#123;</span><br><span class="line">        update(rc[p],mid+1,r,x,L,R,z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>例题 <a href="https://www.luogu.org/problemnew/show/CF786B">CF786B Legacy</a></p><p>这道题还涉及到了区间向某一个点连边的情况，我们再建一个棵线段树在树上反向建边就可以了</p><h2 id="拆点构图"><a href="#拆点构图" class="headerlink" title="拆点构图"></a>拆点构图</h2><p>有些时候我们并不能用一个点来代表一个点（雾）</p><p>诶我不是这个意思。我的意思是用几个点来表示一个点的不同情况。</p><p>随机口胡的一道题</p><p>一个图，每条边上有 $k$ 个权值，第 $i$ 次行走消耗的代价是第 $i%k+1$ 个权值，求某一个点的单源最短路径。 $( k$很小$)$</p><p>看起来直接跑 $dij$ 和 $spfa$ 是不对的，可以自举反例。</p><p>可以使用 $dfs$ ，用 $dis[i][j]$ 表示到第 $i$ 个点走了 $m$ 步且 $m%k+1&#x3D;j$ 的最短方案，但这样太慢了。</p><p>我们可以使用拆点的思想，对于一个点 $i$ ，将它拆为 $i , i+n , i+2*n , …$ 这样的 $k$ 个点，作为到这个点的步数模 $k$ 不同情况的替代点。</p><p>然后我们连边的时候对某一种情况赋不同情况的权值，大概下面这样？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//我们要对 x 到 y 连三种边 w1 w2 w3</span><br><span class="line">add(x,y+n,w1);</span><br><span class="line">add(x+n,y+2*n,w2);</span><br><span class="line">add(x+2*n,y,w3);</span><br></pre></td></tr></table></figure><p>来一张图</p><p><img src="https://z4a.net/images/2019/02/25/k7.png"></p><p>然后在得到的图上跑最短路就可以了，答案要枚举到终点的情况。</p><p>类似的例题 <a href="https://www.luogu.org/problemnew/show/P4568">P4568 飞行路线</a></p><h2 id="图论建模"><a href="#图论建模" class="headerlink" title="图论建模"></a>图论建模</h2><p>似乎……一些背包问题可以用最短路解决，只是没什么必要。</p><p>$Let us AC it–$题面</p><p>$Kodak$开了一家小店赚外快，因为店小，所以只有 $n$ 种不同价格的商品卖，不过好在批发商给力，货源充足，所以每种商品都有无限件。</p><p>因为各种原因，有时候顾客会对购买的总价有特殊的要求，比如计算机科学家泰玛仕一定要总价 $1024$ ，给小姐姐买礼物的面包需要总价 $520$ 或者 $1314$ ，或者纯粹来找茬的张三要买$0$元商品</p><p>但是$Kodak$店里不一定有 $1$ 元的商品，所以并不是所有价格都凑得出来，所以他需要一个程序解决能知道某一个总价能否凑出</p><p>看起来可以用完全背包解决这个问题，但是这道题的数据范围不太友好。</p><p>商品数 $N &lt;&#x3D; 1000$  \  商品价格 $a_i &lt;&#x3D; 20000$<br>顾客数 $M &lt;&#x3D; 300000$  \ 需求价格 $b_i &lt;&#x3D; 40000000$</p><p>如果打完全背包，复杂度会爆炸。$TAT$</p><p>其实这个问题就是 $a_1<em>x_1+a_2</em>x_2+a_3*x_3+…?&#x3D;k$ 的问题。我们考虑 $“$同余 $+$ 最短路$”$</p><p>依题意得，如果 $k$ 满足要求，那么 $a_m<em>k$ 必定也满足条件。我们可以先给它填一堆 $a_m$ ，然后减去 $p$ 个 $a_m$ ，用剩下的 $a_i$ 表示 $p</em>a_m+k%a_m$ 设当 $b%a_m&#x3D;i$时，需要的最小的 $k×a_m+i$ 为 $dis[i]$ ，剩下的即可用最短路的思想来更新，</p><p>跑最短路的过程基本如下</p><pre><code>memset(dis,0x3f,sizeof(dis));dis[0]=0;q.push(0);while(q.size())&#123;    int x=q.top();    q.pop();    if(v[x]) continue;    v[x]=1;    for(int i=1;i&lt;=n;i++)&#123;        int y=(x+a[i])%mod;        if(dis[y]&gt;dis[x]+a[i])&#123;            dis[y]=dis[x]+a[i];            q.push(y);        &#125;    &#125;&#125;</code></pre><p>可能不是太好理解，结合样例手推一下吧</p><hr><p>又一道例题</p><p>给出 $n$ 个 长度为 $m$ 的 $01$ 串，让你确定一个长度相同的 $01$ 串，该串和给出的串中不同的位数最多。</p><p>一道看起来跟图论毫无关系的题，其实也可以当作图论来做</p><p>我们可以建一个 $2^m$ 的图，每个点都与和自身不同位数为 $1$ 的点连一条长度为 $1$ 的边，然后跑 $bfs$，得到最远距离的那个点即为所求。</p><details><summary>广搜代码</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while(h&lt;=t)&#123;</span><br><span class="line">    int x=v[h];</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int z=x^(1&lt;&lt;(i-1));</span><br><span class="line">        if(f[z]==0)&#123;</span><br><span class="line">            f[z]=1;</span><br><span class="line">            t++;</span><br><span class="line">            v[t]=z;</span><br><span class="line">            dis[z]=dis[x]+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这有点类似于前面讲的虚点连边的那道题。</p><p>我讲的可能比较菜，可以画图理解。</p><p>##图论中要注意的坑<br>简单列述几个小问题</p><p>$1.$ 先看眼是有向图还是无向图，无向图数组开两倍。</p><p>$2.$ 如果题目中没有声明无自环和重边，需要注意</p><p>$3.$ 有些遍历的题要考虑环，否则可能死循环，可以使用缩点</p><p>$4.$ 如果题目中边权小于等于零，要考虑负环、零环的情况</p><p>$5.$ 跑最短路的时候要赋初值。</p><p>$6.$ 关于 $Spfa$ ，能不用还是不用吧，毕竟容易被卡。</p>]]></content>
    
    
    <summary type="html">包括但不限于反向建边、虚点连边、线段树优化建边、图论建模、拆点构图</summary>
    
    
    
    
    <category term="Graph theory" scheme="http://example.com/tags/Graph-theory/"/>
    
  </entry>
  
  <entry>
    <title>僕、最近昔の深い物思いに沈んでいた</title>
    <link href="http://example.com/2019/10/03/Memory/"/>
    <id>http://example.com/2019/10/03/Memory/</id>
    <published>2019-10-03T01:00:00.000Z</published>
    <updated>2024-09-03T14:09:57.703Z</updated>
    
    <content type="html"><![CDATA[<p>$&#x2F;&#x2F;12.20$<br>关于$Blog$复活啦！<br>嗯，一想到没准明年$NOIP$之后就要退役了，觉得没准这篇博客就是我$OI$史上的绝唱了……</p><p>$hhh$，希望不会这样。</p><p>$&#x2F;&#x2F;12.15$<br>老是有一种感觉，就是我现在，是已经看到结局的挣扎。</p><p>我站在一个石柱上。每次我想到这些，石柱就崩解一部分。想不到的时候，石柱就缓慢修复。</p><p>拼崩解和修复的速度了。如果石柱崩塌，我就掉进渊里去了。</p><p>那时我心理将完全崩溃。我大概是比较明白吧。</p><p>  ……</p><p> 昨天有个$dalao$跟我聊了聊这方面的东西。大意是我担心的这些不存在。</p><p>然而……我没法信啊。（他自己都不信……我怎么信啊……）</p><p>安慰是一码事，分析又是一码事。</p><p>不一样的。不一样的。</p><p>我现在……算是一厢情愿的在努力吧。</p><p>跟老师谈过，跟家长吵过，跟同学倾诉过，跟？？？交流过，跟自己博弈过……</p><p>其实是我不知道成功的概率有多微茫吗？</p><p>是我不知道吗？</p><p>我徒然追随着美好的幻景，为之耗竭我所有的能量。</p><p>要是我不知道这是折射引起的光学现象也就罢了。</p><p>我一次次的告诉自己，告诉自己这不是海市蜃楼。</p><p>屁话啊，我自己都不信。可是我还是信了。</p><p>就像飞蛾不相信挂在天花板上离自己那么近的东西是月亮。可是它还是相信那是月亮。</p><p>它就跟着它的月亮调整自己飞行的轨迹。它一遍遍地调整，然后发现它并不能通过这个月亮准确地得知自己的坐标，更别提用这个坐标规划自己的夜间活动。</p><p>不过它还是相信这是月亮。</p><p>最后它累死。</p><p>……<br>$&#x2F;&#x2F;12.4$<br>觉得退役了是真的233……</p><p>居然感到一身轻松啊$qwq$</p><p>$&#x2F;&#x2F;10.20$<br>……毕竟大家都是自己路上的使者，他人的事还是少管为好。</p><p>终于决定从明晚开始停课，因为近晚考的不好……$sb$的队列模拟不知道为什么会出现在题目里，并且居然卡$STL$……导致我$rank$疯狂地掉……神经病吧</p><p>233我觉得我和别人的差距，总是这么大……</p><p>看不到光了吗。</p><p>$&#x2F;&#x2F;10.19$<br>今天大概……效率比较低。我成功地带动了机房的人，每人出三道有难度梯度的题，我本来想出一个什么关于序列的水题，之后才发现我不知道该怎么取模……先取模不对，后取模也不对……$GG$</p><p>没啥好说的，晚上就开始停课了。因为实验部信竞文化课普遍$GG$，所以教练就说“自己安排停课时间，想什么时候停就什么时候停”。</p><p>第一批停课……会意味着成功吗？现在连省一都很虚的我，又能怎么回答这个问题呢？</p><p>任务……好艰巨啊。</p><p>$10.18$<br>突然翻到了现在高三的退役大佬的博客，感到很辛酸……我能读出大佬是有多么想获得省一，但当$Day2$来临、心态爆炸时却又多么无奈。如果说我们的实力在一代比一代更加强悍，那也是对的吧；但是这种普适性的东西，放在哪所学校都应该理所当然——全世界都在进步，我们想要成功，只能比其他人站的更高，学的更快，效率更强。</p><p>他去年说今年一定要参加$NOIp$，可是我们现在确定的参赛名额里面，高三的只有一个。</p><p>那个人，不是他。</p><p>……</p><p>我从未想到退役是这样一件可怕的事情，“退役意味着等待”，我原本这么认为。或许“退役意味着永别”从某种程度上，更能反映现在忙碌的社会。一件事情你弃下了，就不要妄图找回来——更何况是在如此需要拼搏的忙碌年华呢…？</p><p>我发现停课之后，效率非常的低下……博客好久没整理了，不行，要努力啊！</p><p>$&#x2F;&#x2F;10.17$<br>今天晚上机房胡策，我提议用$CF$赛制，并且还拟撰了一份赛制规则……并最终决定$3$个小时$6$道题——把老赵给的两套模拟题合并了一下而已。</p><p>然后$GG$——罚时、叉人、没有部分分……我们没有一个成体系的系统来搞这种东西，只能人手用$Lemon$……连罚时都是人工修改测试点分数的$TAT$</p><p>不得不承认，没有经验是一部分原因，另一部分原因还是由于个人太理想主义……</p><p>并且！并且！本来觉得老赵给的题会很友善，但是谁知道一上来的$A$题和$B$题就根本不可做。。。于是乎，本场比赛我觉得最简单的是$D$题……一个线段树就给日过去了，感觉海星$qwq$。</p><p>……之前的几套校外资源都比较友善……为什么突然毒瘤了$233$</p><p>比着比着赛，突然觉得我好想没有勇气去面对失败。我觉得我要更努力 + 更勇敢了，乔丹曾经说过：</p><blockquote><p>当你能够承受所有失败的时候，就是你能够主宰整场比赛的时候。——迈克尔·乔丹</p></blockquote><p>好的，加油吧。</p><p>啊……还有几十天就$NOIP$了啊……</p><p>现在是下午四点，机房。</p><p>比我弱的都在颓废，比我强的都在做题。</p><p>唯独我在写博客。</p><p>我在想些什么呢？</p><p>我是_何雨阳_，没错，我不敢称自己为$Qingmean$，因为这跟我实力不符——我不是那个在$Luogu$这个$OJ$上小有名气的大佬，不是那个题解写得十分详细的作者，更不是SC集训里面排的上号的人。</p><p>没错，我不配啊。</p><p>上午出题，大概是被全方面碾压了吧。省队培训时虽然也考不多好，但是在学校里被平日里玩的很好的朋友碾压却是更加痛苦——我看不见路。</p><p>旁边的窗帘紧紧地闭着、贴着窗户，多云的日子里，挤进来阳光总是给人一种异样的感觉，洒在我的右肩上。</p><p>撇过头来看键盘上发着光的$w$键，突然有种想哭的欲望。</p><p>我是真弱啊。</p><p>$NOIp$现在省一都不稳吧，也就会写几个省选才会考到的板子了；板子也不怎么可以打出来吧，毕竟没有很强的记忆力——天生就是个弱者啊。</p><p>我总是特别羡慕别人敏锐的反应能了，羡慕独到的数学天赋，羡慕稳重的答题习惯，羡慕……</p><p>但我什么也没有。我也不是个富有毅力的人。</p><p>我一直极其富有自尊，十分的自尊。所以我会拼了命地学别人不会的算法，并且十分不喜欢别人善意的和我共同进步，毕竟因为我太弱太弱。</p><p>我发现我这个人好诡异啊……其余走$OI$路的人都没有这种心理波动，只有我会把时间放在这上面吧。</p><p>估计是我什么都不适合吧。</p><p>其实我不是特别喜欢去接近那些很强的人，因为他们总是凭着自己的实力不顾别人的感受。大概在这样的教育制度下，学习好、得了银牌或者怎样，才会有发言权吧。</p><p>这种人强到让我厌恶。也让我悲哀。</p><p>好啦好啦你强好啦……我滚粗好了吧……</p><p>我并不是很服气，但是现实却总是不尽人意。</p><p>过去我一直能依靠着的、可以包容我的人已经与我一别两宽了， 估计以后也只能靠自己了吧。</p><p>我并不知道为什么我要选择承受这么多，大概是天性使然吧。</p><p>我把丘吉尔的一句话当作人生的信条——当然不是唯一的信条。</p><blockquote><p>二战结束后的一天，年老的丘吉尔来到英国下议院，坐在一个年轻的议员旁边，突然问道：“年轻人，你知道是什么东西支撑我在各方面都取得了如此巨大的成就吗？”这个年轻的一员用非常渴望的眼神等待着这位德高望众的伟大人物的教诲，他说：“我非常想知道。”<br>“虚荣心！强烈的虚荣心！”丘吉尔大声说道，随即哈哈大笑，起身而去。</p></blockquote><p>路在哪呢……</p><p>$&#x2F;&#x2F;10.3$<br>现在是晚上3点。啊呸准确的应该是早上……<br>我在干什么啊？？<br>红着眼睛盯着无所事事的$Markdown$编辑框？！<br>好弱啊……连深搜题都能卡，更别提$DP$的啥了……</p><p>我也不知道我在干嘛……也许也许，，学了2个月的$OI$了啊，我还是不够强……这种类似于谦虚的话真不该由我来说啊……说自己太弱吧，像是有$dalao$在故意装弱……其实还是很无奈于自己的现况啊……捕星$QAQ$还是……</p><p>也许这个时候还是需要回忆一下学$OI$的初衷啊……真是可笑，，别人都是到了省选&#x2F;$NOI$的时候才会有我这样的懦弱心理吧……可我做什么，我自己心里明白。</p><p>绵中夏令营的时候，要我们每人选一门竞赛科目，很多人叽里呱啦地说要选信息（其实就是为了能够玩电脑），我却举棋不定。于是整个考试一结束，信息60分，一共招50人我$rank$ 52，无语。好吧，其实也不算太糟糕$qwq$因为我的物理$rank$ 3，生物$rank$ 10，也就是说完全可以读物竞$or$生竞……我的物理暂且不提，生物竞赛是不可能的，什么鬼的肽链多肽听上去无聊死了（坚决讨厌生竞$qwq$）</p><p>可我偏偏脑子抽了硬是要去信息竞赛……暑假结果也没有好好学，一考试就要么爆0要么只能骗骗分……最后并没有进入竞赛班。</p><p>反正绵中的$OI$也是菜的，他们无非比我多一些时间写题，他们吃饭——我写题，他们休息——写题……</p><p>好吧是很傻，但是现在想起来挺可爱的$w$</p><p>抑或是缘分，抑或是直觉，我和这个玄玄学学的竞赛走到了一起。<br>在这感谢@$pks$大佬$Blog$里的一句话：</p><blockquote><p>记住，不论你是走是留，道路是曲折的，但前途是光明的。</p></blockquote><p>走上这条路，我不后悔。我会拼尽全力，至死方休。也算是给自己的一剂强心针吧$w$</p><p>$\huge\text{我坚信：}$<br>$\Huge\text{日拱一卒，功不唐捐！}$</p><p>希望自己越来越强吧。</p>]]></content>
    
    
    <summary type="html">「いつか」は絶対来ない、「いつか使う」は絶対無い 。</summary>
    
    
    
    
    <category term="Meditations" scheme="http://example.com/tags/Meditations/"/>
    
  </entry>
  
</feed>
